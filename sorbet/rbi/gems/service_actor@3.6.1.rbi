# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `service_actor` gem.
# Please instead update this file by running `bin/tapioca gem service_actor`.

# Class to inherit from in your application.
#
# source://service_actor//lib/service_actor.rb#6
class Actor
  include ::ServiceActor::Playable::PrependedMethods
  include ::ServiceActor::Checkable::PrependedMethods
  include ::ServiceActor::Defaultable::PrependedMethods
  include ::ServiceActor::Failable::PrependedMethods
  include ::ServiceActor::Base
  include ::ServiceActor::Core
  include ::ServiceActor::Configurable
  include ::ServiceActor::Attributable
  include ::ServiceActor::Playable
  include ::ServiceActor::Checkable
  include ::ServiceActor::Defaultable
  include ::ServiceActor::Failable
  extend ::ServiceActor::Core::ClassMethods
  extend ::ServiceActor::Configurable::ClassMethods
  extend ::ServiceActor::Attributable::ClassMethods
  extend ::ServiceActor::Playable::ClassMethods
  extend ::ServiceActor::Failable::ClassMethods
end

# source://service_actor//lib/service_actor/support/loader.rb#5
module ServiceActor; end

# Raised when an input or output does not match the given conditions.
#
# source://service_actor//lib/service_actor/argument_error.rb#4
class ServiceActor::ArgumentError < ServiceActor::Error; end

# DSL to document the accepted attributes.
#
#   class CreateUser < Actor
#     input :name
#     output :name
#   end
#
# source://service_actor//lib/service_actor/attributable.rb#9
module ServiceActor::Attributable
  mixes_in_class_methods ::ServiceActor::Attributable::ClassMethods

  class << self
    # @private
    #
    # source://service_actor//lib/service_actor/attributable.rb#10
    def included(base); end
  end
end

# source://service_actor//lib/service_actor/attributable.rb#14
module ServiceActor::Attributable::ClassMethods
  # source://service_actor//lib/service_actor/attributable.rb#15
  def inherited(child); end

  # source://service_actor//lib/service_actor/attributable.rb#22
  def input(name, **arguments); end

  # source://service_actor//lib/service_actor/attributable.rb#35
  def inputs; end

  # source://service_actor//lib/service_actor/attributable.rb#39
  def output(name, **arguments); end

  # source://service_actor//lib/service_actor/attributable.rb#53
  def outputs; end
end

# source://service_actor//lib/service_actor/base.rb#5
module ServiceActor::Base
  include ::ServiceActor::Core
  include ::ServiceActor::Configurable
  include ::ServiceActor::Attributable
  include ::ServiceActor::Playable
  include ::ServiceActor::Checkable
  include ::ServiceActor::Defaultable
  include ::ServiceActor::Failable

  mixes_in_class_methods ::ServiceActor::Core::ClassMethods
  mixes_in_class_methods ::ServiceActor::Configurable::ClassMethods
  mixes_in_class_methods ::ServiceActor::Attributable::ClassMethods
  mixes_in_class_methods ::ServiceActor::Playable::ClassMethods
  mixes_in_class_methods ::ServiceActor::Failable::ClassMethods

  class << self
    # @private
    #
    # source://service_actor//lib/service_actor/base.rb#6
    def included(base); end
  end
end

# source://service_actor//lib/service_actor/checkable.rb#3
module ServiceActor::Checkable
  class << self
    # @private
    #
    # source://service_actor//lib/service_actor/checkable.rb#4
    def included(base); end
  end
end

# source://service_actor//lib/service_actor/checkable.rb#8
module ServiceActor::Checkable::PrependedMethods
  # source://service_actor//lib/service_actor/checkable.rb#9
  def _call; end

  private

  # source://service_actor//lib/service_actor/checkable.rb#52
  def check_classes; end

  # @raise [self.class.argument_error_class]
  #
  # source://service_actor//lib/service_actor/checkable.rb#45
  def raise_actor_argument_errors; end

  # Returns the value of attribute service_actor_argument_errors.
  #
  # source://service_actor//lib/service_actor/checkable.rb#19
  def service_actor_argument_errors; end

  # Sets the attribute service_actor_argument_errors
  #
  # @param value the value to set the attribute service_actor_argument_errors to.
  #
  # source://service_actor//lib/service_actor/checkable.rb#19
  def service_actor_argument_errors=(_arg0); end

  # source://service_actor//lib/service_actor/checkable.rb#22
  def service_actor_checks_for(origin); end
end

module ServiceActor::Checks; end

# source://service_actor//lib/service_actor/checks/base.rb#3
class ServiceActor::Checks::Base
  # @return [Base] a new instance of Base
  #
  # source://service_actor//lib/service_actor/checks/base.rb#4
  def initialize; end

  # Returns the value of attribute argument_errors.
  #
  # source://service_actor//lib/service_actor/checks/base.rb#8
  def argument_errors; end

  protected

  # source://service_actor//lib/service_actor/checks/base.rb#12
  def add_argument_error(message, **arguments); end
end

# Adds the `default:` option to inputs. Accepts regular values and lambdas.
# If no default is set and the value has not been given, raises an error.
#
# Example:
#
#   class MultiplyThing < Actor
#     input :counter, default: 1
#     input :multiplier, default: -> { rand(1..10) }
#   end
#
#   class MultiplyThing < Actor
#     input :counter,
#           default: {
#             is: 1,
#             message: "Counter is required"
#           }
#
#     input :multiplier,
#           default: {
#             is: -> { rand(1..10) },
#             message: (lambda do |input_key:, actor:|
#               "Input \"#{input_key}\" is required"
#             end)
#           }
#   end
#
# source://service_actor//lib/service_actor/checks/default_check.rb#28
class ServiceActor::Checks::DefaultCheck < ServiceActor::Checks::Base
  # @return [DefaultCheck] a new instance of DefaultCheck
  #
  # source://service_actor//lib/service_actor/checks/default_check.rb#38
  def initialize(result:, input_key:, input_options:, actor:); end

  # source://service_actor//lib/service_actor/checks/default_check.rb#47
  def check; end

  private

  # source://service_actor//lib/service_actor/checks/default_check.rb#74
  def default_for_advanced_mode_with(content); end

  # source://service_actor//lib/service_actor/checks/default_check.rb#69
  def default_for_normal_mode_with(default); end

  class << self
    # source://service_actor//lib/service_actor/checks/default_check.rb#29
    def check(result:, input_key:, input_options:, actor:, **_arg4); end
  end
end

# Add checks to your inputs, by specifying what values are authorized under the
# "in" key.
#
# Example:
#
#   class Pay < Actor
#     input :provider, inclusion: ["MANGOPAY", "PayPal", "Stripe"]
#   end
#
#   class Pay < Actor
#     input :provider,
#           inclusion: {
#             in: ["MANGOPAY", "PayPal", "Stripe"],
#             message: (lambda do |input_key:, actor:, inclusion_in:, value:|
#               "Payment system \"#{value}\" is not supported"
#             end)
#           }
#   end
#
# source://service_actor//lib/service_actor/checks/inclusion_check.rb#21
class ServiceActor::Checks::InclusionCheck < ServiceActor::Checks::Base
  # @return [InclusionCheck] a new instance of InclusionCheck
  #
  # source://service_actor//lib/service_actor/checks/inclusion_check.rb#42
  def initialize(input_key:, actor:, inclusion:, value:); end

  # source://service_actor//lib/service_actor/checks/inclusion_check.rb#51
  def check; end

  private

  # source://service_actor//lib/service_actor/checks/inclusion_check.rb#68
  def define_inclusion_and_message; end

  class << self
    # source://service_actor//lib/service_actor/checks/inclusion_check.rb#30
    def check(check_name:, input_key:, actor:, conditions:, result:, **_arg5); end
  end
end

# source://service_actor//lib/service_actor/checks/inclusion_check.rb#22
ServiceActor::Checks::InclusionCheck::DEFAULT_MESSAGE = T.let(T.unsafe(nil), Proc)

# Add checks to your inputs, by calling lambdas with the name of you choice
# under the "must" key.
#
# Will raise an error if any check returns a truthy value.
#
# Example:
#
#   class Pay < Actor
#     input :provider,
#           must: {
#             exist: -> provider { PROVIDERS.include?(provider) },
#           }
#   end
#
#   class Pay < Actor
#     input :provider,
#           must: {
#             exist: {
#               is: -> provider { PROVIDERS.include?(provider) },
#               message: (lambda do |input_key:, check_name:, actor:, value:|
#                 "The specified provider \"#{value}\" was not found."
#               end)
#             }
#           }
#   end
#
# source://service_actor//lib/service_actor/checks/must_check.rb#28
class ServiceActor::Checks::MustCheck < ServiceActor::Checks::Base
  # @return [MustCheck] a new instance of MustCheck
  #
  # source://service_actor//lib/service_actor/checks/must_check.rb#47
  def initialize(input_key:, actor:, nested_checks:, value:); end

  # source://service_actor//lib/service_actor/checks/must_check.rb#56
  def check; end

  private

  # source://service_actor//lib/service_actor/checks/must_check.rb#87
  def define_check_and_message_from(nested_check_conditions); end

  # source://service_actor//lib/service_actor/checks/must_check.rb#76
  def prepared_message_with(nested_check_name, nested_check_conditions); end

  class << self
    # source://service_actor//lib/service_actor/checks/must_check.rb#36
    def check(check_name:, input_key:, actor:, conditions:, result:, **_arg5); end
  end
end

# source://service_actor//lib/service_actor/checks/must_check.rb#29
ServiceActor::Checks::MustCheck::DEFAULT_MESSAGE = T.let(T.unsafe(nil), Proc)

# Ensure your inputs and outputs are not nil by adding `allow_nil: false`.
#
# Example:
#
#   class CreateUser < Actor
#     input :name, allow_nil: false
#     output :user, allow_nil: false
#   end
#
#   class CreateUser < Actor
#     input :name,
#           allow_nil: {
#             is: false,
#             message: (lambda do |origin:, input_key:, actor:|
#               "The value \"#{input_key}\" cannot be empty"
#             end)
#           }
#
#     input :phone, allow_nil: { is: false, message: "Phone must be present" }
#
#     output :user,
#             allow_nil: {
#               is: false,
#               message: (lambda do |origin:, input_key:, actor:|
#                 "The value \"#{input_key}\" cannot be empty"
#               end)
#             }
#   end
#
# source://service_actor//lib/service_actor/checks/nil_check.rb#31
class ServiceActor::Checks::NilCheck < ServiceActor::Checks::Base
  # @return [NilCheck] a new instance of NilCheck
  #
  # source://service_actor//lib/service_actor/checks/nil_check.rb#57
  def initialize(origin:, input_key:, input_options:, actor:, allow_nil:, value:); end

  # source://service_actor//lib/service_actor/checks/nil_check.rb#75
  def check; end

  private

  # @return [Boolean]
  #
  # source://service_actor//lib/service_actor/checks/nil_check.rb#101
  def allow_nil?(tmp_allow_nil); end

  # source://service_actor//lib/service_actor/checks/nil_check.rb#93
  def define_allow_nil_and_message_from(allow_nil); end

  class << self
    # source://service_actor//lib/service_actor/checks/nil_check.rb#38
    def check(origin:, input_key:, input_options:, actor:, conditions:, result:, **_arg6); end
  end
end

# source://service_actor//lib/service_actor/checks/nil_check.rb#32
ServiceActor::Checks::NilCheck::DEFAULT_MESSAGE = T.let(T.unsafe(nil), Proc)

# Adds `type:` checking to inputs and outputs. Accepts class names or classes
# that should match an ancestor. Also accepts arrays.
#
# Example:
#
#   class ReduceOrderAmount < Actor
#     input :order, type: "Order"
#     input :amount, type: [Integer, Float]
#     input :bonus_applied, type: [TrueClass, FalseClass]
#   end
#
#   class ReduceOrderAmount < Actor
#     input :order, type: { is: Order, message: "Order is required" }
#     input :amount, type: { is: Integer, message: "Incorrect amount" }
#
#     input :bonus_applied,
#           type: {
#             is: [TrueClass, FalseClass],
#               "Wrong type \"#{given_type}\" for \"#{input_key}\". " \
#               "Expected: \"#{expected_type}\""
#             end)
#           }
#   end
#
# source://service_actor//lib/service_actor/checks/type_check.rb#27
class ServiceActor::Checks::TypeCheck < ServiceActor::Checks::Base
  # @return [TypeCheck] a new instance of TypeCheck
  #
  # source://service_actor//lib/service_actor/checks/type_check.rb#57
  def initialize(origin:, input_key:, actor:, type_definition:, given_type:); end

  # source://service_actor//lib/service_actor/checks/type_check.rb#67
  def check; end

  private

  # source://service_actor//lib/service_actor/checks/type_check.rb#87
  def define_types_and_message; end

  class << self
    # source://service_actor//lib/service_actor/checks/type_check.rb#37
    def check(check_name:, origin:, input_key:, actor:, conditions:, result:, **_arg6); end
  end
end

# source://service_actor//lib/service_actor/checks/type_check.rb#28
ServiceActor::Checks::TypeCheck::DEFAULT_MESSAGE = T.let(T.unsafe(nil), Proc)

# source://service_actor//lib/service_actor/configurable.rb#3
module ServiceActor::Configurable
  mixes_in_class_methods ::ServiceActor::Configurable::ClassMethods

  class << self
    # @private
    #
    # source://service_actor//lib/service_actor/configurable.rb#4
    def included(base); end
  end
end

# source://service_actor//lib/service_actor/configurable.rb#8
module ServiceActor::Configurable::ClassMethods
  # Returns the value of attribute argument_error_class.
  #
  # source://service_actor//lib/service_actor/configurable.rb#18
  def argument_error_class; end

  # Sets the attribute argument_error_class
  #
  # @param value the value to set the attribute argument_error_class to.
  #
  # source://service_actor//lib/service_actor/configurable.rb#18
  def argument_error_class=(_arg0); end

  # Returns the value of attribute failure_class.
  #
  # source://service_actor//lib/service_actor/configurable.rb#18
  def failure_class; end

  # Sets the attribute failure_class
  #
  # @param value the value to set the attribute failure_class to.
  #
  # source://service_actor//lib/service_actor/configurable.rb#18
  def failure_class=(_arg0); end

  # source://service_actor//lib/service_actor/configurable.rb#9
  def inherited(child); end
end

# source://service_actor//lib/service_actor/core.rb#3
module ServiceActor::Core
  mixes_in_class_methods ::ServiceActor::Core::ClassMethods

  # source://service_actor//lib/service_actor/core.rb#33
  def initialize(result); end

  # This method is used internally to override behavior on call. Overriding
  # `call` instead would mean that end-users have to call `super` in their
  # actors.
  #
  # source://service_actor//lib/service_actor/core.rb#47
  def _call; end

  # To implement in your actors.
  #
  # source://service_actor//lib/service_actor/core.rb#38
  def call; end

  # To implement in your actors.
  #
  # source://service_actor//lib/service_actor/core.rb#41
  def rollback; end

  protected

  # Can be called from inside an actor to stop execution and mark as failed.
  #
  # source://service_actor//lib/service_actor/core.rb#57
  def fail!(**arguments); end

  # Returns the current context from inside an actor.
  #
  # source://service_actor//lib/service_actor/core.rb#54
  def result; end

  class << self
    # @private
    #
    # source://service_actor//lib/service_actor/core.rb#4
    def included(base); end
  end
end

# source://service_actor//lib/service_actor/core.rb#8
module ServiceActor::Core::ClassMethods
  # Call an actor with a given result. Returns the result.
  #
  #   CreateUser.call(name: "Joe")
  #
  # source://service_actor//lib/service_actor/core.rb#12
  def call(result = T.unsafe(nil), **arguments); end

  # Call an actor with arguments. Returns the result and does not raise on
  # failure.
  #
  #   CreateUser.result(name: "Joe")
  #
  # source://service_actor//lib/service_actor/core.rb#25
  def result(result = T.unsafe(nil), **arguments); end
end

# Adds the `default:` option to inputs. Accepts regular values and lambdas.
# If no default is set and the value has not been given, raises an error.
#
# Example:
#
#   class MultiplyThing < Actor
#     input :counter, default: 1
#     input :multiplier, default: -> { rand(1..10) }
#   end
#
#   class MultiplyThing < Actor
#     input :counter,
#           default: {
#             is: 1,
#             message: "Counter is required"
#           }
#
#     input :multiplier,
#           default: {
#             is: -> { rand(1..10) },
#             message: (lambda do |input_key:, actor:|
#               "Input \"#{input_key}\" is required"
#             end)
#           }
#   end
#
# source://service_actor//lib/service_actor/defaultable.rb#28
module ServiceActor::Defaultable
  class << self
    # @private
    #
    # source://service_actor//lib/service_actor/defaultable.rb#29
    def included(base); end
  end
end

# source://service_actor//lib/service_actor/defaultable.rb#33
module ServiceActor::Defaultable::PrependedMethods
  # source://service_actor//lib/service_actor/defaultable.rb#34
  def _call; end

  private

  # source://service_actor//lib/service_actor/defaultable.rb#63
  def default_for_advanced_mode_with(result, key, content); end

  # source://service_actor//lib/service_actor/defaultable.rb#58
  def default_for_normal_mode_with(result, key, default); end

  # Raises an error depending on the mode
  #
  # @raise [self.class.argument_error_class]
  #
  # source://service_actor//lib/service_actor/defaultable.rb#77
  def raise_error_with(message, **arguments); end
end

# Standard exception from which others inherit.
#
# source://service_actor//lib/service_actor/error.rb#4
class ServiceActor::Error < StandardError; end

# Adds the `fail_on` DSL to actors. This allows you to call `.result` and get
# back a failed actor instead of raising an exception.
#
#   class ApplicationActor < Actor
#     fail_on ServiceActor::ArgumentError
#   end
#
# source://service_actor//lib/service_actor/failable.rb#9
module ServiceActor::Failable
  mixes_in_class_methods ::ServiceActor::Failable::ClassMethods

  class << self
    # @private
    #
    # source://service_actor//lib/service_actor/failable.rb#10
    def included(base); end
  end
end

# source://service_actor//lib/service_actor/failable.rb#15
module ServiceActor::Failable::ClassMethods
  # source://service_actor//lib/service_actor/failable.rb#22
  def fail_on(*exceptions); end

  # source://service_actor//lib/service_actor/failable.rb#26
  def fail_ons; end

  # source://service_actor//lib/service_actor/failable.rb#16
  def inherited(child); end
end

# source://service_actor//lib/service_actor/failable.rb#31
module ServiceActor::Failable::PrependedMethods
  # source://service_actor//lib/service_actor/failable.rb#32
  def _call; end
end

# Error raised when using `fail!` inside an actor.
#
# source://service_actor//lib/service_actor/failure.rb#4
class ServiceActor::Failure < ServiceActor::Error
  # @return [Failure] a new instance of Failure
  #
  # source://service_actor//lib/service_actor/failure.rb#5
  def initialize(result); end

  # Returns the value of attribute result.
  #
  # source://service_actor//lib/service_actor/failure.rb#13
  def result; end
end

# Play class method to call a series of actors with the same result. On failure,
# calls rollback on actors that succeeded.
#
#   class CreateUser < Actor
#     play SaveUser,
#          CreateSettings,
#          SendWelcomeEmail
#   end
#
# source://service_actor//lib/service_actor/playable.rb#11
module ServiceActor::Playable
  mixes_in_class_methods ::ServiceActor::Playable::ClassMethods

  class << self
    # @private
    #
    # source://service_actor//lib/service_actor/playable.rb#12
    def included(base); end
  end
end

# source://service_actor//lib/service_actor/playable.rb#17
module ServiceActor::Playable::ClassMethods
  # source://service_actor//lib/service_actor/playable.rb#22
  def alias_input(**options); end

  # source://service_actor//lib/service_actor/playable.rb#34
  def inherited(child); end

  # source://service_actor//lib/service_actor/playable.rb#18
  def play(*actors, **options); end

  # source://service_actor//lib/service_actor/playable.rb#30
  def play_actors; end

  private

  # source://service_actor//lib/service_actor/playable.rb#42
  def define_alias_input(actor, new, original); end
end

# source://service_actor//lib/service_actor/playable.rb#56
module ServiceActor::Playable::PrependedMethods
  # source://service_actor//lib/service_actor/playable.rb#57
  def call; end

  # source://service_actor//lib/service_actor/playable.rb#68
  def rollback; end

  private

  # source://service_actor//lib/service_actor/playable.rb#80
  def play_actor(actor); end

  # source://service_actor//lib/service_actor/playable.rb#105
  def play_interactor(actor); end

  # source://service_actor//lib/service_actor/playable.rb#97
  def play_method(actor); end

  # source://service_actor//lib/service_actor/playable.rb#87
  def play_service_actor(actor); end
end

# Represents the context of an actor, holding the data from both its inputs
# and outputs.
#
# source://service_actor//lib/service_actor/result.rb#7
class ServiceActor::Result < OpenStruct
  # source://service_actor//lib/service_actor/result.rb#50
  def [](name); end

  # Defined here to override the method on `Object`.
  #
  # source://service_actor//lib/service_actor/result.rb#55
  def display; end

  # @raise [failure_class]
  #
  # source://service_actor//lib/service_actor/result.rb#18
  def fail!(failure_class = T.unsafe(nil), result = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://service_actor//lib/service_actor/result.rb#34
  def failure?; end

  # source://service_actor//lib/service_actor/result.rb#14
  def inspect; end

  # @return [Boolean]
  #
  # source://service_actor//lib/service_actor/result.rb#46
  def key?(name); end

  # source://service_actor//lib/service_actor/result.rb#38
  def merge!(result); end

  # @return [Boolean]
  #
  # source://service_actor//lib/service_actor/result.rb#30
  def success?; end

  private

  # source://service_actor//lib/service_actor/result.rb#65
  def method_missing(symbol, *args); end

  # @return [Boolean]
  #
  # source://service_actor//lib/service_actor/result.rb#61
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end

  class << self
    # source://service_actor//lib/service_actor/result.rb#8
    def to_result(data); end
  end
end

# source://service_actor//lib/service_actor/version.rb#4
ServiceActor::VERSION = T.let(T.unsafe(nil), String)
